function fromEuler(t,e,i,o){let r=Math.PI/360;e*=r,o*=r,i*=r;let n=Math.sin(e),s=Math.cos(e),a=Math.sin(i),l=Math.cos(i),h=Math.sin(o),c=Math.cos(o);return t[0]=n*l*c-s*a*h,t[1]=s*a*c+n*l*h,t[2]=s*l*h-n*a*c,t[3]=s*l*c+n*a*h,t}function normalize_vector(t){let e=t[0],i=t[1],o=t[2],r=e*e+i*i+o*o;r>0&&(r=1/Math.sqrt(r)),t[0]*=r,t[1]*=r,t[2]*=r}function cross(t,e,i){let o=e[0],r=e[1],n=e[2],s=i[0],a=i[1],l=i[2];t[0]=r*l-n*a,t[1]=n*s-o*l,t[2]=o*a-r*s}getOpposedVertex=(t,e,i,o)=>{for(let r=0;r<t.length;r+=3){const n=[t[r],t[r+1],t[r+2]];for(let t=0;t<n.length;t++)if(n[(t+2)%3]!=o&&(n[t]==e&&n[(t+1)%3]==i||n[(t+1)%3]==e&&n[t]==i))return n[(t+2)%3]}return-1},weightOddVertex=(t,e,i,o,r,n,s,a)=>{const l=getOpposedVertex(t,o,r,n);-1!=l?(x=(3*i[3*o]+3*i[3*r]+i[3*n]+i[3*l])/8,y=(3*i[3*o+1]+3*i[3*r+1]+i[3*n+1]+i[3*l+1])/8,z=(3*i[3*o+2]+3*i[3*r+2]+i[3*n+2]+i[3*l+2])/8):(x=(i[3*o]+i[3*r])/2,y=(i[3*o+1]+i[3*r+1])/2,z=(i[3*o+2]+i[3*r+2])/2),e[3*s]=x,e[3*s+1]=y,e[3*s+2]=z},weightEvenVertex=(t,e,i,o)=>{let r=i[3*o],n=i[3*o+1],s=i[3*o+2],a=0,l=0,h=0,c=[],f=0;for(let e=0;e<t.length;e+=3){const r=[t[e],t[e+1],t[e+2]];for(let t=0;t<r.length;t++){const e=r[t],n=r[(t+1)%3],s=r[(t+2)%3];e==o&&(c[n]||(c[n]=1,a+=i[3*n],l+=i[3*n+1],h+=i[3*n+2],f++),c[s]||(c[s]=1,a+=i[3*s],l+=i[3*s+1],h+=i[3*s+2],f++))}}let p=1;p=f>3?.375/f:.1875/f,e[3*o]=a*p+r*(1-f*p),e[3*o+1]=l*p+n*(1-f*p),e[3*o+2]=h*p+s*(1-f*p)},findHalfVertex=(t,e,i,o)=>{if(e<t){const i=t;t=e,e=i}const r=1e5*t+e;let n=1;return i[r]||(i[r]=o,n=0),[n,i[r]]},subdivide=(t,e,i,o,r,n,s)=>{for(let a=0;a<s;a++){let l=o.length/3;duplicated=[];for(let s=0;s<e.length;s+=3){const a=e[s],h=e[s+1],c=e[s+2];let[f,p]=findHalfVertex(a,h,duplicated,l);f||(l++,weightOddVertex(e,i,o,a,h,c,p));let[d,u]=findHalfVertex(a,c,duplicated,l);d||(l++,weightOddVertex(e,i,o,a,c,h,u));let[g,m]=findHalfVertex(h,c,duplicated,l);g||(l++,weightOddVertex(e,i,o,h,c,a,m)),weightEvenVertex(e,i,o,a),weightEvenVertex(e,i,o,h),weightEvenVertex(e,i,o,c),t.push(a),t.push(p),t.push(u),t.push(u),t.push(c),t.push(m),t.push(p),t.push(h),t.push(m),t.push(p),t.push(u),t.push(m),r&&(r.push(n[s/3]),r.push(n[s/3]),r.push(n[s/3]),r.push(n[s/3]))}a!=s-1&&(e=[...t],o=[...i],n=[...r])}},generateFaceNormals=(t,e)=>{const i=[];for(let o=0;o<t.length;o+=3){const r=t[o],n=t[o+1],s=t[o+2],a=[],l=[],h=[];for(let t=0;t<3;t++)a[t]=e[3*r+t]-e[3*n+t],l[t]=e[3*s+t]-e[3*n+t];cross(h,a,l),normalize_vector(h),i[o]=h[0],i[o+1]=h[1],i[o+2]=h[2]}return i};const EPSILON=1e-6;function create(){let t=new Float32Array(16);return t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}function copy(t,e){let i=e.length;for(;i--;)t[i]=e[i]}function transformMat4(t,e,i){let o=e[0],r=e[1],n=e[2],s=e[3];return t[0]=i[0]*o+i[4]*r+i[8]*n+i[12]*s,t[1]=i[1]*o+i[5]*r+i[9]*n+i[13]*s,t[2]=i[2]*o+i[6]*r+i[10]*n+i[14]*s,t[3]=i[3]*o+i[7]*r+i[11]*n+i[15]*s,t}function cross(t,e,i){let o=e[0],r=e[1],n=e[2],s=i[0],a=i[1],l=i[2];return t[0]=r*l-n*a,t[1]=n*s-o*l,t[2]=o*a-r*s,t}function normalize(t,e){let i=e[0],o=e[1],r=e[2],n=i*i+o*o+r*r;return n>0&&(n=1/Math.sqrt(n)),t[0]=i*n,t[1]=o*n,t[2]=r*n,t}function fromValues(t,e,i,o,r,n,s,a,l,h,c,f,p,d,u,g){let m=new Float32Array(16);return m[0]=t,m[1]=e,m[2]=i,m[3]=o,m[4]=r,m[5]=n,m[6]=s,m[7]=a,m[8]=l,m[9]=h,m[10]=c,m[11]=f,m[12]=p,m[13]=d,m[14]=u,m[15]=g,m}function set(t,e,i,o,r,n,s,a,l,h,c,f,p,d,u,g,m){return t[0]=e,t[1]=i,t[2]=o,t[3]=r,t[4]=n,t[5]=s,t[6]=a,t[7]=l,t[8]=h,t[9]=c,t[10]=f,t[11]=p,t[12]=d,t[13]=u,t[14]=g,t[15]=m,t}function identity(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function transpose(t,e){if(t===e){let i=e[1],o=e[2],r=e[3],n=e[6],s=e[7],a=e[11];t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=i,t[6]=e[9],t[7]=e[13],t[8]=o,t[9]=n,t[11]=e[14],t[12]=r,t[13]=s,t[14]=a}else t[0]=e[0],t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=e[1],t[5]=e[5],t[6]=e[9],t[7]=e[13],t[8]=e[2],t[9]=e[6],t[10]=e[10],t[11]=e[14],t[12]=e[3],t[13]=e[7],t[14]=e[11],t[15]=e[15];return t}function invert(t,e){let i=e[0],o=e[1],r=e[2],n=e[3],s=e[4],a=e[5],l=e[6],h=e[7],c=e[8],f=e[9],p=e[10],d=e[11],u=e[12],g=e[13],m=e[14],_=e[15],v=i*a-o*s,x=i*l-r*s,L=i*h-n*s,M=o*l-r*a,E=o*h-n*a,A=r*h-n*l,R=c*g-f*u,b=c*m-p*u,T=c*_-d*u,P=f*m-p*g,w=f*_-d*g,y=p*_-d*m,S=v*y-x*w+L*P+M*T-E*b+A*R;return S?(S=1/S,t[0]=(a*y-l*w+h*P)*S,t[1]=(r*w-o*y-n*P)*S,t[2]=(g*A-m*E+_*M)*S,t[3]=(p*E-f*A-d*M)*S,t[4]=(l*T-s*y-h*b)*S,t[5]=(i*y-r*T+n*b)*S,t[6]=(m*L-u*A-_*x)*S,t[7]=(c*A-p*L+d*x)*S,t[8]=(s*w-a*T+h*R)*S,t[9]=(o*T-i*w-n*R)*S,t[10]=(u*E-g*L+_*v)*S,t[11]=(f*L-c*E-d*v)*S,t[12]=(a*b-s*P-l*R)*S,t[13]=(i*P-o*b+r*R)*S,t[14]=(g*x-u*M-m*v)*S,t[15]=(c*M-f*x+p*v)*S,t):null}function adjoint(t,e){let i=e[0],o=e[1],r=e[2],n=e[3],s=e[4],a=e[5],l=e[6],h=e[7],c=e[8],f=e[9],p=e[10],d=e[11],u=e[12],g=e[13],m=e[14],_=e[15],v=i*a-o*s,x=i*l-r*s,L=i*h-n*s,M=o*l-r*a,E=o*h-n*a,A=r*h-n*l,R=c*g-f*u,b=c*m-p*u,T=c*_-d*u,P=f*m-p*g,w=f*_-d*g,y=p*_-d*m;return t[0]=a*y-l*w+h*P,t[1]=r*w-o*y-n*P,t[2]=g*A-m*E+_*M,t[3]=p*E-f*A-d*M,t[4]=l*T-s*y-h*b,t[5]=i*y-r*T+n*b,t[6]=m*L-u*A-_*x,t[7]=c*A-p*L+d*x,t[8]=s*w-a*T+h*R,t[9]=o*T-i*w-n*R,t[10]=u*E-g*L+_*v,t[11]=f*L-c*E-d*v,t[12]=a*b-s*P-l*R,t[13]=i*P-o*b+r*R,t[14]=g*x-u*M-m*v,t[15]=c*M-f*x+p*v,t}function determinant(t){let e=t[0],i=t[1],o=t[2],r=t[3],n=t[4],s=t[5],a=t[6],l=t[7],h=t[8],c=t[9],f=t[10],p=t[11],d=t[12],u=t[13],g=t[14],m=e*s-i*n,_=e*a-o*n,v=i*a-o*s,x=h*u-c*d,L=h*g-f*d,M=c*g-f*u;return l*(e*M-i*L+o*x)-r*(n*M-s*L+a*x)+t[15]*(h*v-c*_+f*m)-p*(d*v-u*_+g*m)}function multiply(t,e,i){let o=e[0],r=e[1],n=e[2],s=e[3],a=e[4],l=e[5],h=e[6],c=e[7],f=e[8],p=e[9],d=e[10],u=e[11],g=e[12],m=e[13],_=e[14],v=e[15],x=i[0],L=i[1],M=i[2],E=i[3];return t[0]=x*o+L*a+M*f+E*g,t[1]=x*r+L*l+M*p+E*m,t[2]=x*n+L*h+M*d+E*_,t[3]=x*s+L*c+M*u+E*v,x=i[4],L=i[5],M=i[6],E=i[7],t[4]=x*o+L*a+M*f+E*g,t[5]=x*r+L*l+M*p+E*m,t[6]=x*n+L*h+M*d+E*_,t[7]=x*s+L*c+M*u+E*v,x=i[8],L=i[9],M=i[10],E=i[11],t[8]=x*o+L*a+M*f+E*g,t[9]=x*r+L*l+M*p+E*m,t[10]=x*n+L*h+M*d+E*_,t[11]=x*s+L*c+M*u+E*v,x=i[12],L=i[13],M=i[14],E=i[15],t[12]=x*o+L*a+M*f+E*g,t[13]=x*r+L*l+M*p+E*m,t[14]=x*n+L*h+M*d+E*_,t[15]=x*s+L*c+M*u+E*v,t}function translate(t,e,i){let o,r,n,s,a,l,h,c,f,p,d,u,g=i[0],m=i[1],_=i[2];return e===t?(t[12]=e[0]*g+e[4]*m+e[8]*_+e[12],t[13]=e[1]*g+e[5]*m+e[9]*_+e[13],t[14]=e[2]*g+e[6]*m+e[10]*_+e[14],t[15]=e[3]*g+e[7]*m+e[11]*_+e[15]):(o=e[0],r=e[1],n=e[2],s=e[3],a=e[4],l=e[5],h=e[6],c=e[7],f=e[8],p=e[9],d=e[10],u=e[11],t[0]=o,t[1]=r,t[2]=n,t[3]=s,t[4]=a,t[5]=l,t[6]=h,t[7]=c,t[8]=f,t[9]=p,t[10]=d,t[11]=u,t[12]=o*g+a*m+f*_+e[12],t[13]=r*g+l*m+p*_+e[13],t[14]=n*g+h*m+d*_+e[14],t[15]=s*g+c*m+u*_+e[15]),t}function scale(t,e,i){let o=i[0],r=i[1],n=i[2];return t[0]=e[0]*o,t[1]=e[1]*o,t[2]=e[2]*o,t[3]=e[3]*o,t[4]=e[4]*r,t[5]=e[5]*r,t[6]=e[6]*r,t[7]=e[7]*r,t[8]=e[8]*n,t[9]=e[9]*n,t[10]=e[10]*n,t[11]=e[11]*n,t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function rotate(t,e,i,o){let r,n,s,a,l,h,c,f,p,d,u,g,m,_,v,x,L,M,E,A,R,b,T,P,w=o[0],y=o[1],S=o[2],C=Math.hypot(w,y,S);return C<EPSILON?null:(C=1/C,w*=C,y*=C,S*=C,r=Math.sin(i),n=Math.cos(i),s=1-n,a=e[0],l=e[1],h=e[2],c=e[3],f=e[4],p=e[5],d=e[6],u=e[7],g=e[8],m=e[9],_=e[10],v=e[11],x=w*w*s+n,L=y*w*s+S*r,M=S*w*s-y*r,E=w*y*s-S*r,A=y*y*s+n,R=S*y*s+w*r,b=w*S*s+y*r,T=y*S*s-w*r,P=S*S*s+n,t[0]=a*x+f*L+g*M,t[1]=l*x+p*L+m*M,t[2]=h*x+d*L+_*M,t[3]=c*x+u*L+v*M,t[4]=a*E+f*A+g*R,t[5]=l*E+p*A+m*R,t[6]=h*E+d*A+_*R,t[7]=c*E+u*A+v*R,t[8]=a*b+f*T+g*P,t[9]=l*b+p*T+m*P,t[10]=h*b+d*T+_*P,t[11]=c*b+u*T+v*P,e!==t&&(t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t)}function rotateX(t,e,i){let o=Math.sin(i),r=Math.cos(i),n=e[4],s=e[5],a=e[6],l=e[7],h=e[8],c=e[9],f=e[10],p=e[11];return e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[4]=n*r+h*o,t[5]=s*r+c*o,t[6]=a*r+f*o,t[7]=l*r+p*o,t[8]=h*r-n*o,t[9]=c*r-s*o,t[10]=f*r-a*o,t[11]=p*r-l*o,t}function rotateY(t,e,i){let o=Math.sin(i),r=Math.cos(i),n=e[0],s=e[1],a=e[2],l=e[3],h=e[8],c=e[9],f=e[10],p=e[11];return e!==t&&(t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=n*r-h*o,t[1]=s*r-c*o,t[2]=a*r-f*o,t[3]=l*r-p*o,t[8]=n*o+h*r,t[9]=s*o+c*r,t[10]=a*o+f*r,t[11]=l*o+p*r,t}function rotateZ(t,e,i){let o=Math.sin(i),r=Math.cos(i),n=e[0],s=e[1],a=e[2],l=e[3],h=e[4],c=e[5],f=e[6],p=e[7];return e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=n*r+h*o,t[1]=s*r+c*o,t[2]=a*r+f*o,t[3]=l*r+p*o,t[4]=h*r-n*o,t[5]=c*r-s*o,t[6]=f*r-a*o,t[7]=p*r-l*o,t}function fromTranslation(t,e){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t}function fromScaling(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function fromRotation(t,e,i){let o,r,n,s=i[0],a=i[1],l=i[2],h=Math.hypot(s,a,l);return h<EPSILON?null:(h=1/h,s*=h,a*=h,l*=h,o=Math.sin(e),r=Math.cos(e),n=1-r,t[0]=s*s*n+r,t[1]=a*s*n+l*o,t[2]=l*s*n-a*o,t[3]=0,t[4]=s*a*n-l*o,t[5]=a*a*n+r,t[6]=l*a*n+s*o,t[7]=0,t[8]=s*l*n+a*o,t[9]=a*l*n-s*o,t[10]=l*l*n+r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t)}function fromXRotation(t,e){let i=Math.sin(e),o=Math.cos(e);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o,t[6]=i,t[7]=0,t[8]=0,t[9]=-i,t[10]=o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function fromYRotation(t,e){let i=Math.sin(e),o=Math.cos(e);return t[0]=o,t[1]=0,t[2]=-i,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=i,t[9]=0,t[10]=o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function fromZRotation(t,e){let i=Math.sin(e),o=Math.cos(e);return t[0]=o,t[1]=i,t[2]=0,t[3]=0,t[4]=-i,t[5]=o,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function fromRotationTranslation(t,e,i){let o=e[0],r=e[1],n=e[2],s=e[3],a=o+o,l=r+r,h=n+n,c=o*a,f=o*l,p=o*h,d=r*l,u=r*h,g=n*h,m=s*a,_=s*l,v=s*h;return t[0]=1-(d+g),t[1]=f+v,t[2]=p-_,t[3]=0,t[4]=f-v,t[5]=1-(c+g),t[6]=u+m,t[7]=0,t[8]=p+_,t[9]=u-m,t[10]=1-(c+d),t[11]=0,t[12]=i[0],t[13]=i[1],t[14]=i[2],t[15]=1,t}function fromQuat2(t,e){let i=Float32Array(3),o=-e[0],r=-e[1],n=-e[2],s=e[3],a=e[4],l=e[5],h=e[6],c=e[7],f=o*o+r*r+n*n+s*s;return f>0?(i[0]=2*(a*s+c*o+l*n-h*r)/f,i[1]=2*(l*s+c*r+h*o-a*n)/f,i[2]=2*(h*s+c*n+a*r-l*o)/f):(i[0]=2*(a*s+c*o+l*n-h*r),i[1]=2*(l*s+c*r+h*o-a*n),i[2]=2*(h*s+c*n+a*r-l*o)),fromRotationTranslation(t,e,i),t}function getTranslation(t,e){return t[0]=e[12],t[1]=e[13],t[2]=e[14],t}function getScaling(t,e){let i=e[0],o=e[1],r=e[2],n=e[4],s=e[5],a=e[6],l=e[8],h=e[9],c=e[10];return t[0]=Math.hypot(i,o,r),t[1]=Math.hypot(n,s,a),t[2]=Math.hypot(l,h,c),t}function getRotation(t,e){let i=new Float32Array(3);getScaling(i,e);let o=1/i[0],r=1/i[1],n=1/i[2],s=e[0]*o,a=e[1]*r,l=e[2]*n,h=e[4]*o,c=e[5]*r,f=e[6]*n,p=e[8]*o,d=e[9]*r,u=e[10]*n,g=s+c+u,m=0;return g>0?(m=2*Math.sqrt(g+1),t[3]=.25*m,t[0]=(f-d)/m,t[1]=(p-l)/m,t[2]=(a-h)/m):s>c&&s>u?(m=2*Math.sqrt(1+s-c-u),t[3]=(f-d)/m,t[0]=.25*m,t[1]=(a+h)/m,t[2]=(p+l)/m):c>u?(m=2*Math.sqrt(1+c-s-u),t[3]=(p-l)/m,t[0]=(a+h)/m,t[1]=.25*m,t[2]=(f+d)/m):(m=2*Math.sqrt(1+u-s-c),t[3]=(a-h)/m,t[0]=(p+l)/m,t[1]=(f+d)/m,t[2]=.25*m),t}function decompose(t,e,i,o){e[0]=o[12],e[1]=o[13],e[2]=o[14];let r=o[0],n=o[1],s=o[2],a=o[4],l=o[5],h=o[6],c=o[8],f=o[9],p=o[10];i[0]=Math.hypot(r,n,s),i[1]=Math.hypot(a,l,h),i[2]=Math.hypot(c,f,p);let d=1/i[0],u=1/i[1],g=1/i[2],m=r*d,_=n*u,v=s*g,x=a*d,L=l*u,M=h*g,E=c*d,A=f*u,R=p*g,b=m+L+R,T=0;return b>0?(T=2*Math.sqrt(b+1),t[3]=.25*T,t[0]=(M-A)/T,t[1]=(E-v)/T,t[2]=(_-x)/T):m>L&&m>R?(T=2*Math.sqrt(1+m-L-R),t[3]=(M-A)/T,t[0]=.25*T,t[1]=(_+x)/T,t[2]=(E+v)/T):L>R?(T=2*Math.sqrt(1+L-m-R),t[3]=(E-v)/T,t[0]=(_+x)/T,t[1]=.25*T,t[2]=(M+A)/T):(T=2*Math.sqrt(1+R-m-L),t[3]=(_-x)/T,t[0]=(E+v)/T,t[1]=(M+A)/T,t[2]=.25*T),t}function fromRotationTranslationScale(t,e,i,o){let r=e[0],n=e[1],s=e[2],a=e[3],l=r+r,h=n+n,c=s+s,f=r*l,p=r*h,d=r*c,u=n*h,g=n*c,m=s*c,_=a*l,v=a*h,x=a*c,L=o[0],M=o[1],E=o[2];return t[0]=(1-(u+m))*L,t[1]=(p+x)*L,t[2]=(d-v)*L,t[3]=0,t[4]=(p-x)*M,t[5]=(1-(f+m))*M,t[6]=(g+_)*M,t[7]=0,t[8]=(d+v)*E,t[9]=(g-_)*E,t[10]=(1-(f+u))*E,t[11]=0,t[12]=i[0],t[13]=i[1],t[14]=i[2],t[15]=1,t}function fromRotationTranslationScaleOrigin(t,e,i,o,r){let n=e[0],s=e[1],a=e[2],l=e[3],h=n+n,c=s+s,f=a+a,p=n*h,d=n*c,u=n*f,g=s*c,m=s*f,_=a*f,v=l*h,x=l*c,L=l*f,M=o[0],E=o[1],A=o[2],R=r[0],b=r[1],T=r[2],P=(1-(g+_))*M,w=(d+L)*M,y=(u-x)*M,S=(d-L)*E,C=(1-(p+_))*E,F=(m+v)*E,I=(u+x)*A,B=(m-v)*A,O=(1-(p+g))*A;return t[0]=P,t[1]=w,t[2]=y,t[3]=0,t[4]=S,t[5]=C,t[6]=F,t[7]=0,t[8]=I,t[9]=B,t[10]=O,t[11]=0,t[12]=i[0]+R-(P*R+S*b+I*T),t[13]=i[1]+b-(w*R+C*b+B*T),t[14]=i[2]+T-(y*R+F*b+O*T),t[15]=1,t}function fromQuat(t,e){let i=e[0],o=e[1],r=e[2],n=e[3],s=i+i,a=o+o,l=r+r,h=i*s,c=o*s,f=o*a,p=r*s,d=r*a,u=r*l,g=n*s,m=n*a,_=n*l;return t[0]=1-f-u,t[1]=c+_,t[2]=p-m,t[3]=0,t[4]=c-_,t[5]=1-h-u,t[6]=d+g,t[7]=0,t[8]=p+m,t[9]=d-g,t[10]=1-h-f,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function frustum(t,e,i,o,r,n,s){let a=1/(i-e),l=1/(r-o),h=1/(n-s);return t[0]=2*n*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2*n*l,t[6]=0,t[7]=0,t[8]=(i+e)*a,t[9]=(r+o)*l,t[10]=(s+n)*h,t[11]=-1,t[12]=0,t[13]=0,t[14]=s*n*2*h,t[15]=0,t}function perspectiveNO(t,e,i,o,r){const n=1/Math.tan(e/2);if(t[0]=n/i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=r&&r!==1/0){const e=1/(o-r);t[10]=(r+o)*e,t[14]=2*r*o*e}else t[10]=-1,t[14]=-2*o;return t}const perspective=perspectiveNO;function perspectiveZO(t,e,i,o,r){const n=1/Math.tan(e/2);if(t[0]=n/i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=r&&r!==1/0){const e=1/(o-r);t[10]=r*e,t[14]=r*o*e}else t[10]=-1,t[14]=-o;return t}function perspectiveFromFieldOfView(t,e,i,o){let r=Math.tan(e.upDegrees*Math.PI/180),n=Math.tan(e.downDegrees*Math.PI/180),s=Math.tan(e.leftDegrees*Math.PI/180),a=Math.tan(e.rightDegrees*Math.PI/180),l=2/(s+a),h=2/(r+n);return t[0]=l,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=h,t[6]=0,t[7]=0,t[8]=-(s-a)*l*.5,t[9]=(r-n)*h*.5,t[10]=o/(i-o),t[11]=-1,t[12]=0,t[13]=0,t[14]=o*i/(i-o),t[15]=0,t}function orthoNO(t,e,i,o,r,n,s){const a=1/(e-i),l=1/(o-r),h=1/(n-s);return t[0]=-2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*l,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*h,t[11]=0,t[12]=(e+i)*a,t[13]=(r+o)*l,t[14]=(s+n)*h,t[15]=1,t}const ortho=orthoNO;function orthoZO(t,e,i,o,r,n,s){const a=1/(e-i),l=1/(o-r),h=1/(n-s);return t[0]=-2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*l,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=h,t[11]=0,t[12]=(e+i)*a,t[13]=(r+o)*l,t[14]=n*h,t[15]=1,t}function lookAt(t,e,i,o){let r,n,s,a,l,h,c,f,p,d,u=e[0],g=e[1],m=e[2],_=o[0],v=o[1],x=o[2],L=i[0],M=i[1],E=i[2];return Math.abs(u-L)<EPSILON&&Math.abs(g-M)<EPSILON&&Math.abs(m-E)<EPSILON?identity(t):(c=u-L,f=g-M,p=m-E,d=1/Math.hypot(c,f,p),c*=d,f*=d,p*=d,r=v*p-x*f,n=x*c-_*p,s=_*f-v*c,d=Math.hypot(r,n,s),d?(d=1/d,r*=d,n*=d,s*=d):(r=0,n=0,s=0),a=f*s-p*n,l=p*r-c*s,h=c*n-f*r,d=Math.hypot(a,l,h),d?(d=1/d,a*=d,l*=d,h*=d):(a=0,l=0,h=0),t[0]=r,t[1]=a,t[2]=c,t[3]=0,t[4]=n,t[5]=l,t[6]=f,t[7]=0,t[8]=s,t[9]=h,t[10]=p,t[11]=0,t[12]=-(r*u+n*g+s*m),t[13]=-(a*u+l*g+h*m),t[14]=-(c*u+f*g+p*m),t[15]=1,t)}function targetTo(t,e,i,o){let r=e[0],n=e[1],s=e[2],a=o[0],l=o[1],h=o[2],c=r-i[0],f=n-i[1],p=s-i[2],d=c*c+f*f+p*p;d>0&&(d=1/Math.sqrt(d),c*=d,f*=d,p*=d);let u=l*p-h*f,g=h*c-a*p,m=a*f-l*c;return d=u*u+g*g+m*m,d>0&&(d=1/Math.sqrt(d),u*=d,g*=d,m*=d),t[0]=u,t[1]=g,t[2]=m,t[3]=0,t[4]=f*m-p*g,t[5]=p*u-c*m,t[6]=c*g-f*u,t[7]=0,t[8]=c,t[9]=f,t[10]=p,t[11]=0,t[12]=r,t[13]=n,t[14]=s,t[15]=1,t}const segments=[new Path2D("M1,1 2,0 8,0 9,1 8,2 2,2z"),new Path2D("M9,1 10,2 10,8 9,9 8,8 8,2z"),new Path2D("M9,9 10,10 10,16 9,17 8,16 8,10z"),new Path2D("M9,17 8,18 2,18 1,17 2,16 8,16z"),new Path2D("M1,17 0,16 0,10 1,9 2,10 2,16z"),new Path2D("M1,9 0,8 0,2 1,1 2,2 2,8z"),new Path2D("M1,9 2,8 8,8 9,9 8,10 2,10z")],chars=[63,6,91,79,102,109,125,7,127,111,73,0,0,0,0,0,0,119,124,88,94,121,113,61,116,4,30,117,56,55,84,92,115,103,80,109,120,28,62,126,118,110,91];drawText=(t,e,i,o,r,n=0,s=1)=>{t.save();let a=r/12,l=-n*r*e.length*.5;t.translate(i+l,o-20*a/2);for(let i=0;i<e.length;i++){let o=chars[e.charCodeAt(i)-48];t.save(),t.scale(a,a);let r=1;for(let e=0;e<7;e++)t.globalAlpha=o&r?s:.1*s,t.fill(segments[e]),r*=2;t.restore(),t.translate(12*a,0)}t.restore()};let ship_vertex_opt=[],ship_vertex_opt2=[],ship_indices_opt=[],ship_indices_opt2=[];const ship_vertex=[],ship_indices=[],ship_vertex_colors=[],ship_normals=[];let ship_face_colors=[];const ship_vertexStr="GI0IM0KI0HJ3IK3JJ3EHIMHIHI1HIHJIHJI1HJHJJHIPIEEMMEMEFbMFb?CM?DbSCMSDb=IM=IbUIMUIb@LM@LbRLMRLbFIbLIbEFdMFdFHdLHdEFfMFfFHfLHfAKM@KMQKMRKM",ship_indicesStr="*-/*/,*.-*.++/.+,/-./*03*32*25*5,,14,45236547347376014043267275,18,8+*08*8+09:0:19;<9<::<@:@?9>;9=>?@D?DC=>B=BAABFAFECDHCHG1:<1<809;0;88<J8;I;<J;JI8IJKOQKQMLPRLRNMNRMRQKLPKPOEFSSTFEFTESTGHUUVHGHVGUV";for(let t=0;t<ship_vertexStr.length;t++)ship_vertex_opt2.push(ship_vertexStr.charCodeAt(t)-73);for(let t=0;t<ship_indicesStr.length;t++)ship_indices_opt2.push(ship_indicesStr.charCodeAt(t)-42);const YELLOW=[.2,.2,.3,1],DARK_YELLOW=[.1,.1,.1,1],RED=[.6,.6,.7,1],COCKPIT=[.5,.5,.8,.8],DARK_RED=[.4,.4,.5,1],ship_face_colors2=[YELLOW,YELLOW,YELLOW,YELLOW,YELLOW,YELLOW,RED,RED,RED,RED,RED,RED,RED,DARK_RED,DARK_RED,DARK_RED,DARK_RED,RED,RED,YELLOW,YELLOW,RED,RED,RED,RED,COCKPIT,COCKPIT,RED,RED,RED,RED,RED,RED,DARK_RED,DARK_RED,DARK_RED,DARK_RED,RED,RED,RED,RED,DARK_YELLOW,YELLOW,DARK_YELLOW,YELLOW,YELLOW,YELLOW,YELLOW,YELLOW,YELLOW,YELLOW,YELLOW,YELLOW,YELLOW,YELLOW,[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1],[0,0,0,1]];ship_indices_opt=ship_indices_opt2,ship_vertex_opt=ship_vertex_opt2,ship_face_colors=[...ship_face_colors2];const ship_normals_opt=generateFaceNormals(ship_indices_opt,ship_vertex_opt);for(let t=0;t<ship_indices_opt.length;t++){let e=3*ship_indices_opt[t];ship_indices.push(t),ship_vertex.push(ship_vertex_opt[e]),ship_vertex.push(ship_vertex_opt[e+1]),ship_vertex.push(ship_vertex_opt[e+2]),ship_vertex_colors.push(...ship_face_colors[t/3|0]),ship_normals.push(ship_normals_opt[e]),ship_normals.push(ship_normals_opt[e+1]),ship_normals.push(ship_normals_opt[e+2])}class RenderObject{constructor(t){this.attribLocations={},this.uniformLocations={},this.id=t,this.ttl=1,this._position=[0,0,0],this.position=[0,0,0],this.position_t=[0,0,0],this.collisions=!1,this.objective=!1,this.related=[],this.scale_t=1,this._scale=1,this.scale=1,this.modelViewMatrix=create(),this.factor=1}setPosition=t=>{this.position[0]=this._position[0]=this.position_t[0]=t[0],this.position[1]=this._position[1]=this.position_t[1]=t[1],this.position[2]=this._position[2]=this.position_t[2]=t[2]};move=(t,e)=>{this.position_t[0]+=e[0]*t,this.position_t[1]+=e[1]*t,this.position_t[2]+=e[2]*t,this.related.forEach((i=>i.move(t,e)))};init=t=>{this.shaderProgram=buildShaderProgram(this.vertexShader(),this.fragmentShader()),this.attribLocations.vertexPosition=gl.getAttribLocation(this.shaderProgram,"aVertexPosition"),this.attribLocations.vertexColor=gl.getAttribLocation(this.shaderProgram,"aVertexColor"),this.uniformLocations.projectionMatrix=gl.getUniformLocation(this.shaderProgram,"uProjectionMatrix"),this.uniformLocations.modelViewMatrix=gl.getUniformLocation(this.shaderProgram,"uModelViewMatrix"),this.uniformLocations.cameraMatrix=gl.getUniformLocation(this.shaderProgram,"uCameraMatrix"),this.uniformLocations.factor=gl.getUniformLocation(this.shaderProgram,"factor"),this.vertexBufferId=gl.createBuffer(),gl.bindBuffer(gl.ARRAY_BUFFER,this.vertexBufferId),gl.bufferData(gl.ARRAY_BUFFER,this.vertexBuffer(),gl.STATIC_DRAW),gl.vertexAttribPointer(this.attribLocations.vertexPosition,3,gl.FLOAT,!1,0,0),this.colorBufferId=gl.createBuffer(),gl.bindBuffer(gl.ARRAY_BUFFER,this.colorBufferId),gl.bufferData(gl.ARRAY_BUFFER,this.colorBuffer(),gl.STATIC_DRAW),gl.vertexAttribPointer(this.attribLocations.vertexColor,4,gl.FLOAT,!1,0,0),this.indexBufferId=gl.createBuffer(),gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.indexBufferId),gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,this.indexBuffer(),gl.STATIC_DRAW)};getModelViewMatrix=t=>(fromTranslation(this.modelViewMatrix,this.position),this.modelViewMatrix);colorBuffer=t=>[];indexBuffer=t=>[];vertexBuffer=t=>[];logicTick=(t,e,i)=>{};preRender=t=>{};postRender=t=>{};logicStep=t=>{};boundingBox=t=>[0,0,0,0,0,0];vertexShader=t=>"\n        attribute vec4 aVertexPosition;\n        attribute vec4 aVertexColor;\n        uniform mat4 uModelViewMatrix;\n        uniform mat4 uProjectionMatrix;\n        uniform mat4 uCameraMatrix;\n        varying lowp vec4 vColor;\n\n        void main(void) {\n          gl_Position = uProjectionMatrix * uCameraMatrix * uModelViewMatrix * aVertexPosition;\n          vColor = aVertexColor;\n        }\n    ";fragmentShader=t=>"\n      precision mediump float;\n      varying lowp vec4 vColor;\n      uniform float factor;\n\n      void main(void) {\n        gl_FragColor = vColor;\n      }\n    "}const FRAGMENT_SHADER=0,VERTEX_SHADER=1;buildShader=(t,e)=>{let i=gl.createShader(0==t?gl.FRAGMENT_SHADER:gl.VERTEX_SHADER);return gl.shaderSource(i,e),gl.compileShader(i),gl.getShaderParameter(i,gl.COMPILE_STATUS)?i:(console.log("An error occurred compiling the "+(0==t?"fragment":"vertex")+" shader: "+gl.getShaderInfoLog(i)+" :"+e),null)},buildShaderProgram=(t,e)=>{var i=gl.createProgram();if(gl.attachShader(i,buildShader(1,t)),gl.attachShader(i,buildShader(0,e)),gl.linkProgram(i),!gl.getProgramParameter(i,gl.LINK_STATUS))throw"Could not link the shader program!";return i},drawObject=(t,e,i,o,r)=>{gl.useProgram(i.shaderProgram),gl.bindBuffer(gl.ARRAY_BUFFER,i.vertexBufferId),gl.enableVertexAttribArray(i.attribLocations.vertexPosition),gl.vertexAttribPointer(i.attribLocations.vertexPosition,3,gl.FLOAT,!1,0,0),gl.bindBuffer(gl.ARRAY_BUFFER,i.colorBufferId),gl.enableVertexAttribArray(i.attribLocations.vertexColor),gl.vertexAttribPointer(i.attribLocations.vertexColor,4,gl.FLOAT,!1,0,0),gl.uniformMatrix4fv(i.uniformLocations.projectionMatrix,!1,t),gl.uniformMatrix4fv(i.uniformLocations.cameraMatrix,!1,e),gl.uniform1f(i.uniformLocations.factor,i.factor),gl.uniformMatrix4fv(i.uniformLocations.modelViewMatrix,!1,i.getModelViewMatrix()),i.preRender(o),gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,i.indexBufferId),gl.drawElements(gl.TRIANGLES,i.indexBuffer().length,gl.UNSIGNED_SHORT,0),i.postRender(o),gl.disableVertexAttribArray(i.attribLocations.vertexPosition),gl.disableVertexAttribArray(i.attribLocations.vertexColor)};class Sphere extends RenderObject{constructor(t,e,i,o,r,n=!1,s=[0,0,0]){super(t),this.attribLocations={},this.uniformLocations={},this.id=t,this.ttl=1,this.slices=e,this.stacks=i,this.radius=o,this.color=r,this.alphaCloud=n,this.displacement=s,this.fixed=!1,this.fixed_position=[0,0,0],this.collisions=!n}init=t=>{const e=[],i=[],o=[];e.push(0),e.push(1),e.push(0);for(let t=0;t<this.stacks-1;t++){const i=Math.PI*(t+1)/this.stacks;for(let t=0;t<this.slices;t++){const o=2*Math.PI*t/this.slices;e.push(Math.sin(i)*Math.cos(o)*this.radius),e.push(Math.cos(i)*this.radius),e.push(Math.sin(i)*Math.sin(o)*this.radius)}}e.push(0),e.push(-1),e.push(0);for(let t=0;t<this.slices;t++){let r=t+1,n=(t+2)%this.slices;i.push(0,r,n),r=t+this.slices*(this.stacks-2),n=(t+1)%this.slices+this.slices*(this.stacks-2),i.push((e.length-3)/3,r,n);for(let t=0;t<3;t++)o.push(...this.color)}for(let t=0;t<this.stacks-2;t++){const e=t*this.slices+1,r=(t+1)*this.slices+1;for(let t=0;t<this.slices;t++){i.push(e+t),i.push(e+(t+1)%this.slices),i.push(r+(t+1)%this.slices),i.push(r+(t+1)%this.slices),i.push(r+t),i.push(e+t);for(let t=0;t<6;t++)o.push(...this.color)}}this.vertex=new Float32Array(e),this.indices=new Uint16Array(i),this.colors=new Float32Array(o),this.position=[0,0,0],this.shaderProgram=buildShaderProgram(this.vertexShader(),this.fragmentShader()),this.attribLocations.vertexPosition=gl.getAttribLocation(this.shaderProgram,"aVertexPosition"),this.attribLocations.vertexColor=gl.getAttribLocation(this.shaderProgram,"aVertexColor"),this.uniformLocations.projectionMatrix=gl.getUniformLocation(this.shaderProgram,"uProjectionMatrix"),this.uniformLocations.modelViewMatrix=gl.getUniformLocation(this.shaderProgram,"uModelViewMatrix"),this.uniformLocations.cameraMatrix=gl.getUniformLocation(this.shaderProgram,"uCameraMatrix"),this.uniformLocations.col=gl.getUniformLocation(this.shaderProgram,"col"),this.uniformLocations.alphaCloud=gl.getUniformLocation(this.shaderProgram,"alphaCloud"),this.uniformLocations.t=gl.getUniformLocation(this.shaderProgram,"t"),this.uniformLocations.displacement=gl.getUniformLocation(this.shaderProgram,"displacement"),this.uniformLocations.factor=gl.getUniformLocation(this.shaderProgram,"factor"),this.vertexBufferId=gl.createBuffer(),gl.bindBuffer(gl.ARRAY_BUFFER,this.vertexBufferId),gl.bufferData(gl.ARRAY_BUFFER,this.vertex,gl.STATIC_DRAW),gl.vertexAttribPointer(this.attribLocations.vertexPosition,3,gl.FLOAT,!1,0,0),this.colorBufferId=gl.createBuffer(),gl.bindBuffer(gl.ARRAY_BUFFER,this.colorBufferId),gl.bufferData(gl.ARRAY_BUFFER,this.colors,gl.STATIC_DRAW),gl.vertexAttribPointer(this.attribLocations.vertexColor,4,gl.FLOAT,!1,0,0),this.indexBufferId=gl.createBuffer(),gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.indexBufferId),gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,this.indices,gl.STATIC_DRAW)};getModelViewMatrix=t=>(fromTranslation(this.modelViewMatrix,this.fixed?this.fixed_position:this.position),scale(this.modelViewMatrix,this.modelViewMatrix,[this.scale,this.scale,this.scale]),this.modelViewMatrix);colorBuffer=t=>this.colors;indexBuffer=t=>this.indices;vertexBuffer=t=>this.vertex;logicTick=(t,e,i)=>{this.fixed&&(this.fixed_position[0]=e.x+this.position[0],this.fixed_position[1]=e.y+this.position[1],this.fixed_position[2]=e.z+this.position[2]),this._position[0]+=(this.position_t[0]-this._position[0])/16,this._position[1]+=(this.position_t[1]-this._position[1])/16,this._position[2]+=(this.position_t[2]-this._position[2])/16,this._scale+=(this.scale_t-this._scale)/16};logicStep=t=>{for(let e=0;e<3;e++)this.position[e]=this._position[e]+t*(this.position_t[e]-this._position[e])/16;this.scale=this._scale+t*(this.scale_t-this._scale)/16,this.scale<.1&&(this.ttl=0)};scaleTarget=t=>{this.scale_t=t,this.related.forEach((e=>e.scaleTarget(t)))};boundingBox=t=>[this.position[0]-this.radius,this.position[1]-this.radius,this.position[2]-this.radius,this.position[0]+this.radius,this.position[1]+this.radius,this.position[2]+this.radius];preRender=t=>{gl.uniform4fv(this.uniformLocations.col,this.color),gl.uniform1i(this.uniformLocations.alphaCloud,this.alphaCloud),gl.uniform1f(this.uniformLocations.t,1e-5*t),gl.uniform3fv(this.uniformLocations.displacement,this.displacement),this.alphaCloud&&gl.disable(gl.CULL_FACE)};postRender=t=>{gl.enable(gl.CULL_FACE)};vertexShader=t=>"\n      attribute vec4 aVertexPosition;\n      attribute vec4 aVertexColor;\n      uniform mat4 uModelViewMatrix;\n      uniform mat4 uProjectionMatrix;\n      uniform mat4 uCameraMatrix;\n      varying lowp vec4 vColor;\n      varying vec4 vPos;\n\n      void main(void) {\n        vPos = aVertexPosition;\n        gl_Position = uProjectionMatrix * uCameraMatrix * uModelViewMatrix * vPos;\n        vColor = aVertexColor;\n      }\n  ";fragmentShader=t=>"\n    precision mediump float;\n    varying lowp vec4 vPos;\n\n    uniform vec4 col;\n    uniform vec3 displacement;\n    uniform int alphaCloud;\n    uniform float t;\n    uniform float factor;\n\n    float occ = 1.0;\n\n    float hash(vec3 p)  // replace this by something better\n    {\n        p  = fract( p*0.3183099+.1 );\n        p *= 17.0;\n        return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n    }\n    \n    float noise( in vec3 x )\n    {\n        vec3 i = floor(x);\n        vec3 f = fract(x);\n        f = f*f*(3.0-2.0*f);\n      \n        return mix(mix(mix( hash(i+vec3(0,0,0)), \n                            hash(i+vec3(1,0,0)),f.x),\n                       mix( hash(i+vec3(0,1,0)), \n                            hash(i+vec3(1,1,0)),f.x),f.y),\n                   mix(mix( hash(i+vec3(0,0,1)), \n                            hash(i+vec3(1,0,1)),f.x),\n                       mix( hash(i+vec3(0,1,1)), \n                            hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n    }\n    \n    void main(void) {\n      vec3 pos = vPos.xyz * 0.01 + t * displacement;\n      vec4 shade = vec4(0.9);\n      float f = 0.0;\n      \n      vec3 q = 8.0*pos;\n      f  = 0.5000*noise( q ); q = q*2.01;\n      f += 0.2500*noise( q ); q = q*2.02;\n      f += 0.1250*noise( q ); q = q*2.03;\n      f += 0.0625*noise( q ); q = q*2.01;\n      \n      f *= occ;\n\n      if (alphaCloud == 1) {\n        if (f > 0.7) f = 1.0;\n        else if (f > 0.5) f = 0.6;\n        else f = 0.0;\n\n        gl_FragColor = vec4(col.xyz, f * factor);\n      } else {\n        f = sqrt(f*1.5);\n        \n\n        if (f > 0.67) f = 1.0;\n        else if (f > 0.2) f = 0.5;\n        else f = 0.0;\n        \n        gl_FragColor = vec4(f * col.xyz, factor);\n      }\n    }\n    "}const LASER_SPEED=20,LASER_TTL=250;class Laser extends RenderObject{constructor(t){super(t),this.attribLocations={},this.uniformLocations={},this.id=t,this.direction=[0,0,1,0],this.ttl=250,this.rotation_quat=[0,0,0,0],this.directionMatrix=create(),this.modelViewMatrix=create()}init=t=>{this.vertex=new Float32Array([-.1,-.1,20,.1,-.1,20,.1,.1,20,-.1,.1,20,-.1,-.1,-20,-.1,.1,-20,.1,.1,-20,.1,-.1,-20,-.1,.1,-20,-.1,.1,20,.1,.1,20,.1,.1,-20,-.1,-.1,-20,.1,-.1,-20,.1,-.1,20,-.1,-.1,20,.1,-.1,-20,.1,.1,-20,.1,.1,20,.1,-.1,20,-.1,-.1,-20,-.1,-.1,20,-.1,.1,20,-.1,.1,-20]);const e=[[.2,0,1,1],[.2,0,1,1],[.2,0,1,1],[.2,0,1,1],[.2,0,1,1],[.2,0,1,1]];let i=[];for(let t=0;t<e.length;++t){const o=e[t];i=i.concat(o,o,o,o)}this.colors=new Float32Array(i),this.indices=new Uint16Array([0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]),this.position=[0,0,0],this.shaderProgram=buildShaderProgram(this.vertexShader(),this.fragmentShader()),this.attribLocations.vertexPosition=gl.getAttribLocation(this.shaderProgram,"aVertexPosition"),this.attribLocations.vertexColor=gl.getAttribLocation(this.shaderProgram,"aVertexColor"),this.uniformLocations.projectionMatrix=gl.getUniformLocation(this.shaderProgram,"uProjectionMatrix"),this.uniformLocations.modelViewMatrix=gl.getUniformLocation(this.shaderProgram,"uModelViewMatrix"),this.uniformLocations.cameraMatrix=gl.getUniformLocation(this.shaderProgram,"uCameraMatrix"),this.uniformLocations.factor=gl.getUniformLocation(this.shaderProgram,"factor"),this.vertexBufferId=gl.createBuffer(),gl.bindBuffer(gl.ARRAY_BUFFER,this.vertexBufferId),gl.bufferData(gl.ARRAY_BUFFER,this.vertexBuffer(),gl.STATIC_DRAW),gl.vertexAttribPointer(this.attribLocations.vertexPosition,3,gl.FLOAT,!1,0,0),this.colorBufferId=gl.createBuffer(),gl.bindBuffer(gl.ARRAY_BUFFER,this.colorBufferId),gl.bufferData(gl.ARRAY_BUFFER,this.colorBuffer(),gl.STATIC_DRAW),gl.vertexAttribPointer(this.attribLocations.vertexColor,4,gl.FLOAT,!1,0,0),this.indexBufferId=gl.createBuffer(),gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.indexBufferId),gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,this.indexBuffer(),gl.STATIC_DRAW)};getModelViewMatrix=t=>(fromRotationTranslation(this.modelViewMatrix,this.rotation_quat,this.position),this.modelViewMatrix);colorBuffer=t=>this.colors;indexBuffer=t=>this.indices;vertexBuffer=t=>this.vertex;logicTick=(t,e,i)=>{for(let t=0;t<3;t++)this._position[t]+=20*this.direction[t];for(const[t,e]of Object.entries(i))if(t!=this.id&&e.collisions){const t=e.boundingBox();this.position[0]>=t[0]&&this.position[0]<=t[3]&&this.position[1]>=t[1]&&this.position[1]<=t[4]&&this.position[2]>=t[2]&&this.position[2]<=t[5]&&(e.move(250,this.direction),this.ttl=0)}this.ttl--};logicStep=t=>{for(let e=0;e<3;e++)this.position[e]=this._position[e]+t*(20*this.direction[e])}}class Background extends Sphere{constructor(t,e,i,o){super(t,e,i,o,[0,0,0]),this.ship_position=[0,0,0],this.collisions=!1}getModelViewMatrix=t=>{const e=create();return translate(e,e,this.ship_position),e};preRender=t=>{gl.disable(gl.CULL_FACE),gl.depthMask(!1),gl.uniform1f(this.uniformLocations.t,.001*t)};postRender=t=>{gl.enable(gl.CULL_FACE),gl.depthMask(!0)};fragmentShader=t=>"\n      #define TAU 6.28318\n      #define PI 3.141592\n\n      precision mediump float;\n\n      const float rotation_speed = 0.3;\n      varying lowp vec4 vPos;\n      uniform float t;\n      uniform float factor;\n      \n      vec3 hash33(vec3 p3) {\n        p3 = fract(p3 * vec3(.1031,.11369,.13787));\n        p3 += dot(p3, p3.yxz+19.19);\n        return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n      }\n\n      float simplexNoise(vec3 p) {\n        const float K1 = 0.333333333;\n        const float K2 = 0.166666667;\n\n        vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n        vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n        \n        vec3 e = step(vec3(0.0), d0 - d0.yzx);\n        vec3 i1 = e * (1.0 - e.zxy);\n        vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n        \n        vec3 d1 = d0 - (i1 - 1.0 * K2);\n        vec3 d2 = d0 - (i2 - 2.0 * K2);\n        vec3 d3 = d0 - (1.0 - 3.0 * K2);\n        \n        vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n        vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n        \n        return dot(vec4(31.316), n);\n      }\n\n      float fBm3(vec3 p) {\n        float f = 0.0;\n        float scale = 5.0;\n        p = mod(p, scale);\n        float amp = 0.75;\n\n\t      for (int i = 0; i < 5; i++) {\n          f += simplexNoise(p * scale) * amp;\n          amp *= 0.5;\n\t\t      scale *= 2.0;\n        }\n        \n\t      return min(f, 1.0);\n      }\n\n      vec3 hyperspace(vec2 uv, vec3 hypcol) {\n        vec3 col = vec3(0.0);\n        vec2 p = uv * 0.05;\n        \n        vec3 v = vec3(p, 1.0);\n        float v_xy = length(v.xy);\n        float z = v.z / v_xy;\n    \n        float focal_depth = 0.15;\n        vec2 polar;\n    \n        float p_len = length(v.xy);\n    \n        polar.y = z * focal_depth + t;\n    \n        float a = atan(v.y, v.x);\n        a = 0.5 + 0.5 * a / (1.0 * PI);\n        a -= t * rotation_speed;\n        \n        float x = fract(a);\n        if (x >= 0.5) x = 1.0 - x;\n        polar.x = x;\n        \n        float val = 0.45 + 0.55 * fBm3(vec3(vec2(2.0, 0.5) * polar, 0.15 * t));\n        val = clamp(val, 0.0, 1.0);\n        col.rgb = hypcol * vec3(val);\n        \n        vec3 white = 0.35 * vec3(smoothstep(0.55, 1.0, val));\n        col.rgb += white;\n        col.rgb = clamp(col.rgb, 0.0, 1.0);\n    \n        float disk_col = exp(-(p_len - 0.025) * 4.0);\n        col.rgb += clamp(vec3(disk_col), 0.0, 1.0);\n    \n        return col;\n      }\n\n      vec3 stars(vec2 uv) {\n        vec3 col = vec3(0);\n        vec2 gv = fract(uv)-.5;\n        vec2 id = floor(uv);\n        \n        for(int y = -1; y<= 1; y++) {\n          for(int x = -1; x<= 1; x++) {\n              vec2 offs = vec2(x, y);\n              vec2 p = id + offs;\n\n              p = fract(p*vec2(123.34, 456.21));\n              p += dot(p, p+45.32);\n              float n = fract(p.x*p.y);\n\n              float size = fract(n*345.32);\n\n              float d = length(gv - offs - vec2(n-.5, fract(n*34.)-.5));\n              float star = .01/d;\n              star *= smoothstep(1., .1, d);\n\n              vec3 color = sin(vec3(.3, .1, .9)*fract(n*2345.2))*.5+.5;\n              col += star * (sin(t*2. + n*6.2813)*.2+.8) * size * color;\n          }\n        }\n\n        return col;\n      }\n\n      void main(){\n          vec2 uv = vPos.xy * .08;\n          vec2 uv2 = -vPos.xy * .1;\n          vec3 hypcol1 = vec3(0.2, 0.4, 0.9);\n          vec3 hypcol2 = vec3(0.5, 0.5, 0.5);\n          vec3 col = stars(uv) * (1.0 - factor) + (hyperspace(uv, hypcol1)*0.7 + hyperspace(uv2, hypcol2)*0.3)* factor;\n\n          gl_FragColor = vec4(col,1.0);\n      }\n    "}class Circle extends RenderObject{constructor(t,e,i,o){super(t),this.slices=e,this.scale=i,this.fixed=!1,this.color=o,this.fixed_position=[0,0,0],this.position=[0,0,0],this.rotation=0,this._rotation=0}init=t=>{const e=[0,0,0],i=[],o=[];for(let t=0;t<=this.slices;t++)e.push(this.scale*Math.sin(t/this.slices*Math.PI*2)),e.push(this.scale*Math.cos(t/this.slices*Math.PI*2)),e.push(0);for(let t=0;t<=this.slices;t++)i.push(0),i.push(t),i.push(t+1),o.push(1,1,1,1),o.push(1,1,1,1),o.push(1,1,1,1);this.vertex=new Float32Array(e),this.indices=new Uint16Array(i),this.colors=new Float32Array(o),this.shaderProgram=buildShaderProgram(this.vertexShader(),this.fragmentShader()),this.attribLocations.vertexPosition=gl.getAttribLocation(this.shaderProgram,"aVertexPosition"),this.attribLocations.vertexColor=gl.getAttribLocation(this.shaderProgram,"aVertexColor"),this.uniformLocations.projectionMatrix=gl.getUniformLocation(this.shaderProgram,"uProjectionMatrix"),this.uniformLocations.modelViewMatrix=gl.getUniformLocation(this.shaderProgram,"uModelViewMatrix"),this.uniformLocations.cameraMatrix=gl.getUniformLocation(this.shaderProgram,"uCameraMatrix"),this.uniformLocations.col=gl.getUniformLocation(this.shaderProgram,"col"),this.uniformLocations.t=gl.getUniformLocation(this.shaderProgram,"t"),this.uniformLocations.factor=gl.getUniformLocation(this.shaderProgram,"factor"),this.vertexBufferId=gl.createBuffer(),gl.bindBuffer(gl.ARRAY_BUFFER,this.vertexBufferId),gl.bufferData(gl.ARRAY_BUFFER,this.vertex,gl.STATIC_DRAW),gl.vertexAttribPointer(this.attribLocations.vertexPosition,3,gl.FLOAT,!1,0,0),this.colorBufferId=gl.createBuffer(),gl.bindBuffer(gl.ARRAY_BUFFER,this.colorBufferId),gl.bufferData(gl.ARRAY_BUFFER,this.colors,gl.STATIC_DRAW),gl.vertexAttribPointer(this.attribLocations.vertexColor,4,gl.FLOAT,!1,0,0),this.indexBufferId=gl.createBuffer(),gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.indexBufferId),gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,this.indices,gl.STATIC_DRAW)};getModelViewMatrix=t=>(fromTranslation(this.modelViewMatrix,this.fixed?this.fixed_position:this.position),rotate(this.modelViewMatrix,this.modelViewMatrix,.7*this.rotation,[1,1,1]),scale(this.modelViewMatrix,this.modelViewMatrix,[this.scale,this.scale,this.scale]),this.modelViewMatrix);colorBuffer=t=>this.colors;indexBuffer=t=>this.indices;vertexBuffer=t=>this.vertex;logicTick=(t,e,i)=>{this._rotation+=3e-4,this.fixed&&(this.fixed_position[0]=e.x+this.position[0],this.fixed_position[1]=e.y+this.position[1],this.fixed_position[2]=e.z+this.position[2]),this._position[0]+=(this.position_t[0]-this._position[0])/16,this._position[1]+=(this.position_t[1]-this._position[1])/16,this._position[2]+=(this.position_t[2]-this._position[2])/16,this._scale+=(this.scale_t-this._scale)/16};logicStep=t=>{this.rotation=this._rotation+3e-4*t;for(let e=0;e<3;e++)this.position[e]=this._position[e]+t*(this.position_t[e]-this._position[e])/16;this.scale=this._scale+t*(this.scale_t-this._scale)/16,this.scale<.1&&(this.ttl=0)};scaleTarget=t=>{this.scale_t=t,this.related.forEach((e=>e.scaleTarget(t)))};preRender=t=>{gl.disable(gl.CULL_FACE),gl.uniform4fv(this.uniformLocations.col,this.color),gl.uniform1f(this.uniformLocations.t,1e-5*t)};postRender=t=>{gl.enable(gl.CULL_FACE)};vertexShader=t=>"\n      attribute vec4 aVertexPosition;\n      attribute vec4 aVertexColor;\n      uniform mat4 uModelViewMatrix;\n      uniform mat4 uProjectionMatrix;\n      uniform mat4 uCameraMatrix;\n      varying lowp vec4 vColor;\n      varying vec4 vPos;\n\n      void main(void) {\n        vPos = aVertexPosition;\n        gl_Position = uProjectionMatrix * uCameraMatrix * uModelViewMatrix * vPos;\n        vColor = aVertexColor;\n      }\n    ";fragmentShader=t=>"\n      precision mediump float;\n      varying lowp vec4 vPos;\n\n      uniform vec4 col;\n      uniform float t;\n      uniform float factor;\n  \n      void main(void) {\n        float s = sin(sqrt(vPos.x*vPos.x + vPos.y*vPos.y + vPos.z*vPos.z)*0.25);\n        if(s > 0.5) {\n          gl_FragColor = vec4(col.rgb,.7*factor);\n        } else {\n          gl_FragColor = vec4(col.rgb,.1*factor);\n        }\n      }\n      "}class BlackHole extends Circle{constructor(t,e,i,o){super(t,e,i,[1,0,0,1])}preRender=t=>{gl.disable(gl.CULL_FACE),gl.uniform4fv(this.uniformLocations.col,this.color),gl.uniform1f(this.uniformLocations.t,1e-5*t),gl.depthMask(!1)};postRender=t=>{gl.enable(gl.CULL_FACE),gl.depthMask(!0)};logicTick=(t,e,i)=>{for(const[t,e]of Object.entries(i))if(t!=this.id&&e.collisions){const t=e.boundingBox();this.position[0]>=t[0]&&this.position[0]<=t[3]&&this.position[1]>=t[1]&&this.position[1]<=t[4]&&this.position[2]>=t[2]&&this.position[2]<=t[5]&&e.scaleTarget(0)}};fragmentShader=t=>"\n      precision mediump float;\n      varying lowp vec4 vPos;\n\n      uniform float t;\n      uniform vec4 col;\n      uniform float factor;\n  \n      void main(void) {\n        float s = sin(sqrt(vPos.x*vPos.x + vPos.y*vPos.y + vPos.z*vPos.z)*0.25 + t*500.0);\n        if(s > 0.5) {\n          gl_FragColor = vec4(col.rgb,.7*factor);\n        } else {\n          gl_FragColor = vec4(col.rgb,.1*factor);\n        }\n      }\n      "}const MOUSE_FACTOR=.2,FRAME_TIME=20,STATE_MENU=0,STATE_SHOP=1,STATE_GAME=2,STATE_OPTIONS=3,STATE_HELP=4,MAX_ENGINE_POWER=2,SHIP_FIRE_TTL=10;let canvas3D=document.getElementsByTagName`canvas`[0],gl=canvas3D.getContext`webgl`,canvas2D=document.getElementsByTagName`canvas`[1],c=canvas2D.getContext`2d`,moveR=moveL=moveF=moveB=powerUP=powerDOWN=rollL=rollR=firePress=fire=0,lastX=lastY=0,clicked=0,lastT=-1,objectId=0,gameState=0,objectList=[],deleteQueue=[],waveTime=0,wave=1,remaining=0,inputEnabled=!0,ship={x:0,y:0,z:0,speed:0,rotation_quat:[0,0,0,0],direction:[0,0,0,0],directionMatrix:create(),shields_power:0,engine_power:0,_engine_power:0,engine_power_t:0,pitch:0,_pitch:0,pitch_t:0,yaw:0,_yaw:0,yaw_t:0,roll:0,_roll:0,roll_t:0,up:[0,0,0,0],hor:[0,0,0,0],fire_ttl:0,fuel:999,lost:!1};const projectionMatrix=create(),cameraMatrix=create(),laserMatrix=create(),pyrMatrix=create();window.addEventListener("keydown",(t=>{39!=t.keyCode&&68!=t.keyCode||(moveR=1),37!=t.keyCode&&65!=t.keyCode||(moveL=1),38!=t.keyCode&&87!=t.keyCode||(moveF=1),40!=t.keyCode&&83!=t.keyCode||(moveB=1),81==t.keyCode&&(powerUP=1),69==t.keyCode&&(powerDOWN=1),90==t.keyCode&&(rollL=1),88==t.keyCode&&(rollR=1),32==t.keyCode&&(firePress=1),82==t.keyCode&&ship.lost&&(wave=1,generateWave(objectList))})),window.addEventListener("keyup",(t=>{39!=t.keyCode&&68!=t.keyCode||(moveR=0),37!=t.keyCode&&65!=t.keyCode||(moveL=0),38!=t.keyCode&&87!=t.keyCode||(moveF=0),40!=t.keyCode&&83!=t.keyCode||(moveB=0),81==t.keyCode&&(powerUP=0),69==t.keyCode&&(powerDOWN=0),90==t.keyCode&&(rollL=0),88==t.keyCode&&(rollR=0),32==t.keyCode&&(firePress=0)})),window.addEventListener("mousedown",(t=>{lastX=t.clientX,lastY=t.clientY,clicked=1})),window.addEventListener("mouseup",(t=>{clicked=0})),window.addEventListener("mousemove",(t=>{lastX=t.clientX,lastY=t.clientY})),getID=t=>objectId++,init3D=t=>{const e=45*Math.PI/180,i=canvas3D.width/canvas3D.height;gl.enable(gl.DEPTH_TEST),gl.depthFunc(gl.LEQUAL),perspective(projectionMatrix,e,i,.1,8e3)},resetShipState=t=>{ship={x:0,y:0,z:0,speed:0,rotation_quat:[0,0,0,0],direction:[0,0,0,0],directionMatrix:create(),shields_power:0,engine_power:0,_engine_power:0,engine_power_t:0,pitch:0,_pitch:0,pitch_t:0,yaw:0,_yaw:0,yaw_t:0,roll:0,_roll:0,roll_t:0,up:[0,0,0,0],hor:[0,0,0,0],fire_ttl:0,fuel:999,lost:!1}},processInput=t=>{1==moveR&&(ship.yaw_t-=1),1==moveL&&(ship.yaw_t+=1),1==moveF&&(ship.pitch_t-=1),1==moveB&&(ship.pitch_t+=1),1==powerUP&&(ship.engine_power_t+=.15),1==powerDOWN&&(ship.engine_power_t-=.15),ship.shields_power>1&&(ship.shields_power=1),ship.shields_power<0&&(ship.shields_power=0),ship.engine_power_t>2&&(ship.engine_power_t=2),ship.engine_power_t<0&&(ship.engine_power_t=0),rollL&&(ship.roll_t-=1),rollR&&(ship.roll_t+=1),fire=firePress},shipLogicTick=t=>{ship.fuel<=0&&(ship.engine_power=0,ship._engine_power=0,ship.engine_power_t=0),ship._engine_power+=(ship.engine_power_t-ship._engine_power)/16,ship.speed+=(ship._engine_power-ship.speed)/16,ship.fuel-=.25*ship._engine_power,ship.x+=4*ship.direction[0]*ship.speed,ship.y+=4*ship.direction[1]*ship.speed,ship.z+=4*ship.direction[2]*ship.speed,ship._pitch+=(ship.pitch_t-ship._pitch)/16,ship._yaw+=(ship.yaw_t-ship._yaw)/16,ship._roll+=(ship.roll_t-ship._roll)/16,ship.fire_ttl>0&&ship.fire_ttl--},generateWave=t=>{inputEnabled=!1,t.length=0,t[background.id]=background,background.factor=1,resetShipState();const e=new BlackHole(getID(),40,200);e.init(),e.setPosition([0,0,-1e3]),t[e.id]=e;let i=wave+Math.random()*wave*2|0;1==wave&&(i=1);for(let e=0;e<i;e++){let e=50+150*Math.random(),i=2e3*Math.random()-1e3,o=2e3*Math.random()-1e3,r=1e3*Math.random()-500;1==wave&&(i=0,o=0,r=-500,e=40);let n=new Sphere(getID(),20,20,e,[Math.random(),Math.random(),Math.random(),1],!1,[.001,.02,.01]);n.init(),n.setPosition([i,o,r]),n.objective=!0,t[n.id]=n;let s=new Sphere(getID(),20,20,1.05*e,[.3*Math.random()+.7,.3*Math.random()+.7,.3*Math.random()+.7,1],!0,[.3,.2,.5]);if(s.init(),s.setPosition([i,o,r]),t[s.id]=s,n.related.push(s),Math.random()>=.5){let s=Math.random()*e*1.5+1.2*e,a=new Circle(getID(),40,s,[.4*Math.random()+.6,.4*Math.random()+.6,.4*Math.random()+.6,1]);a.init(),a.setPosition([i,o,r]),a._rotation=Math.random()*Math.PI,t[a.id]=a,n.related.push(a)}}waveTime=-1,remaining=i,ship.fuel=999},shipLogicStep=t=>{ship.engine_power=ship._engine_power+t*(ship.engine_power_t-ship._engine_power)/16,ship.roll=ship._roll+t*(ship.roll_t-ship._roll)/16,ship.pitch=ship._pitch+t*(ship.pitch_t-ship._pitch)/16,ship.yaw=ship._yaw+t*(ship.yaw_t-ship._yaw)/16,fromEuler(ship.rotation_quat,ship.pitch,ship.yaw,ship.roll),fromRotationTranslation(ship.directionMatrix,ship.rotation_quat,[ship.x,ship.y,ship.z]),invert(cameraMatrix,ship.directionMatrix),transformMat4(ship.direction,[0,0,-1,0],ship.directionMatrix),transformMat4(ship.up,[0,1,0,0],ship.directionMatrix),transformMat4(ship.hor,[1,0,0,0],ship.directionMatrix),background.ship_position=[ship.x,ship.y,ship.z],fire&&0==ship.fire_ttl&&ship.fuel>0&&(ship.fuel--,shipFireLaser([0,-.5,0]))},shipFireLaser=t=>{let e=new Laser(getID());e.init(),copy(e.rotation_quat,ship.rotation_quat),copy(e.direction,ship.direction),e.setPosition([ship.x+t[0]*ship.hor[0]+t[1]*ship.up[0]+t[2]*ship.direction[0],ship.y+t[0]*ship.hor[1]+t[1]*ship.up[1]+t[2]*ship.direction[1],ship.z+t[0]*ship.hor[2]+t[1]*ship.up[2]+t[2]*ship.direction[2]]),objectList[e.id]=e,ship.fire_ttl=10},easeOut=(t,e,i)=>{i<0&&(i=0),i>1&&(i=1);const o=1-(1-i)*(1-i);return t*(1-o)+e*o},easeInOut_t=t=>(t<0&&(t=0),t>1&&(t=1),t<.5?8*t*t*t*t:1-Math.pow(-2*t+2,4)/2),easeInOut=(t,e,i)=>{const o=easeInOut_t(i);return t*(1-o)+e*o},getPaddingNumber=t=>(t<10?"O":"")+t;let background=new Background(getID(),20,20,500);background.init(),render=t=>{let e=window.innerWidth,i=window.innerHeight;switch(canvas3D.width=e,canvas3D.height=i,canvas2D.width=e,canvas2D.height=i,gl.viewport(0,0,e,i),init3D(),fire=0,inputEnabled&&processInput(),gameState){case 0:for(;t-lastT>=20;)menuLogicTick(t),lastT+=20;menuLogicStep((t-lastT)/20),renderMenu(c,e,i,["MENU","PLAY","HELP"],ship,(t=>{clicked=!1,1==t&&(wave=1,generateWave(objectList),gameState=2),2==t&&(gameState=4)}));break;case 4:for(;t-lastT>=20;)menuLogicTick(t),lastT+=20;menuLogicStep((t-lastT)/20),renderMenu(c,e,i,["HELP","BACK"],ship,(t=>{clicked=!1,1==t&&(gameState=0)})),c.globalAlpha=.8,c.fillStyle="#fff",c.strokeStyle="#000";const o=e/50;c.fillRect(e/10+e/5,i/4-2*o,e,16*o),c.strokeRect(e/10+e/5,i/4-2*o,e,16*o),c.fillStyle="#000",drawText(c,"MISSION ::",e/10+e/5+o,i/4+-1.25*o,o/2),drawText(c,"IN EACH GALAXY SEARCH FOR ALL PLANETS",e/10+e/5+o,i/4+0*o,o/2),drawText(c,"AND PUSH THEM THROUGH THE BLACK HOLE",e/10+e/5+o,i/4+1*o,o/2),drawText(c,"YOU HAVE LIMITED FUEL :: DO NOT GET LOST IN SPACE",e/10+e/5+o,i/4+2*o,o/2),drawText(c,"ARROWS :: MOVE",e/10+e/5+o,i/4+4*o,o),drawText(c,"WASD   :: MOVE",e/10+e/5+o,i/4+6*o,o),drawText(c,"Q      :: ENGINE POWER UP",e/10+e/5+o,i/4+8*o,o),drawText(c,"E      :: ENGINE POWER DOWN",e/10+e/5+o,i/4+10*o,o),drawText(c,"SPACE  :: FIRE PLANET PUSHER",e/10+e/5+o,i/4+12*o,o);break;case 2:for(-1==waveTime&&(waveTime=t),gl.enable(gl.BLEND),gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA),gl.enable(gl.CULL_FACE);t-lastT>=20;){shipLogicTick(t);for(const[e,i]of Object.entries(objectList))i.logicTick(t,ship,objectList);lastT+=20}for(const[t,e]of Object.entries(objectList))e.ttl<=0&&deleteQueue.push(t);deleteQueue.forEach((t=>{objectList[t].objective&&remaining--,delete objectList[t]})),deleteQueue.length=0;const r=(t-lastT)/20;shipLogicStep(r);for(const[t,e]of Object.entries(objectList))e.logicStep(r);gl.clearColor(0,0,0,1),gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);for(const[e,i]of Object.entries(objectList))drawObject(projectionMatrix,cameraMatrix,i,t,ship);renderHUD(c,e,i,ship,objectList);let n=(t-waveTime-1500)/1e3,s=easeInOut(0,1,n),a=easeInOut(-e,e/2,n);for(const[t,e]of Object.entries(objectList))0!=t&&(e.factor=0);if(hudAlpha=0,1==s){n=(t-waveTime-4500)/2500,s=easeInOut(1,0,n),a=easeInOut(e/2,2*e,n),background.factor=s,hudAlpha=1-s;for(const[t,e]of Object.entries(objectList))0!=t&&(e.factor=1-s);inputEnabled=s<.5}let l=e/12;c.fillStyle="#000";const h="GALAXY "+getPaddingNumber(wave);drawText(c,h,a+l/16,i/2+l/16,l,1,s),c.fillStyle="#fff",drawText(c,h,a,i/2,l,1,s),l=e/120,c.lineWidth=4,c.strokeStyle="#fff",c.beginPath(),c.moveTo(a-e/2,i/2+e/10),c.lineTo(a+e/2,i/2+e/10),c.stroke();const f=getPaddingNumber(50*ship.engine_power|0),p=getPaddingNumber(ship.fuel/10|0),d=getPaddingNumber(remaining);if(drawText(c,"GLXY "+getPaddingNumber(wave),e,e/120,l,2),drawText(c,"LEFT "+d,e,e/120+2*l,l,2),drawText(c,"ENGN "+f,e,e/120+4*l,l,2),drawText(c,"FUEL "+p,e,e/120+6*l,l,2),0==remaining&&(wave++,generateWave(objectList)),ship.fuel<=0&&remaining>0){ship.lost=!0,hudAlpha=0;let t=e/16;c.fillStyle="#000",drawText(c,"LOST IN SPACE",e/2+t/16,i/2+t/16,t,1),drawText(c,"R TO RESTART",e/2+t/48,i/2+3*t+t/48,t/3,1),c.fillStyle="#fff",drawText(c,"LOST IN SPACE",e/2,i/2,t,1),drawText(c,"R TO RESTART",e/2,i/2+3*t,t/3,1),c.lineWidth=4,c.strokeStyle="#fff",c.beginPath(),c.moveTo(a-e/2,i/2+e/10),c.lineTo(a+e/2,i/2+e/10),c.stroke()}}requestAnimationFrame(render)},requestAnimationFrame(render);const SEGMENTS=8;let hudAlpha=1;renderHUD=(t,e,i,o,r)=>{const n="#faac00",s="#2ec0e8",a=e/100;t.save(),t.globalAlpha=.8*hudAlpha,t.strokeStyle=s,t.beginPath(),t.arc(e/2,i/2,e/35,0,2*Math.PI),t.moveTo(e/2-1.5*a,i/2-1.5*a),t.lineTo(e/2-4*a,i/2-4*a),t.moveTo(e/2+1.5*a,i/2-1.5*a),t.lineTo(e/2+4*a,i/2-4*a),t.moveTo(e/2-1.5*a,i/2+1.5*a),t.lineTo(e/2-4*a,i/2+4*a),t.moveTo(e/2+1.5*a,i/2+1.5*a),t.lineTo(e/2+4*a,i/2+4*a),t.moveTo(e/2,i/2-2*a),t.lineTo(e/2,i/2-5*a),t.moveTo(e/2,i/2+2*a),t.lineTo(e/2,i/2+5*a),t.moveTo(e/2-2*a,i/2),t.lineTo(e/2-5*a,i/2),t.moveTo(e/2+2*a,i/2),t.lineTo(e/2+5*a,i/2),t.stroke(),t.lineWidth=2,t.strokeStyle=n;for(let o=0;o<4;o++)t.save(),t.translate(e/2,i/2),t.rotate(Math.PI*o/2),t.translate(-e/2,-i/2),t.beginPath(),t.moveTo(e/2-a/2,i/2-a),t.lineTo(e/2,i/2-1.5*a),t.lineTo(e/2+a/2,i/2-a),t.stroke(),t.restore();t.beginPath(),t.rect(0,0,e,i),t.moveTo(e/2+e/30,i/2),t.arc(e/2,i/2,e/32,0,2*Math.PI),t.clip("evenodd");for(let r=0;r<8;r++){let a=r*Math.PI/8;t.fillStyle=r/6<=o.engine_power/2?n:"#9a4c00",t.beginPath(),t.moveTo(e/2,i/2+5),t.arc(e/2,i/2+5,e/(25+.4*(8-r)),a,a+Math.PI/10),t.fill(),t.fillStyle=r/7<o.fuel/1e3?s:"#006088",t.beginPath(),t.moveTo(e/2,i/2-5),t.arc(e/2,i/2-5,e/(25+.4*(8-r)),a+Math.PI,a+Math.PI+Math.PI/10),t.fill()}t.restore()};const FOV=2048,ZOFF=75,TITLE=":08800";let backgroundGradientV=null,backgroundGradientH=null,menuAlpha=_menuAlpha=0,menuAlpha_t=1,angle=0,movement=0,rot=0,_rot=0,rot_t=0;const tmpArray=[],rotatedVertex=[];menuLogicTick=t=>{_menuAlpha+=(menuAlpha_t-_menuAlpha)/16,movement=5e-4*t,_rot+=(rot_t-_rot)/16},menuLogicStep=t=>{menuAlpha=_menuAlpha+t*(menuAlpha_t-_menuAlpha)/16,rot=_rot+t*(rot_t-_rot)/16},rotateY=(t,e,i)=>{const o=Math.cos(i),r=Math.sin(i);for(let i=0;i<e.length;i+=3)t[i]=e[i]*o+e[i+2]*r,t[i+1]=e[i+1],t[i+2]=e[i]*r-e[i+2]*o},rotateX=(t,e,i)=>{const o=Math.cos(i),r=Math.sin(i);for(let i=0;i<e.length;i+=3)t[i]=e[i],t[i+1]=e[i+1]*o+e[i+2]*r,t[i+2]=e[i+1]*r-e[i+2]*o},drawWire=(t,e,i,o,r,n="#000")=>{for(let s=0;s<t.length;s+=3){let a=3*t[s],l=3*t[s+1],h=3*t[s+2],f=FOV*e[a]/(r+e[a+2])+i,p=FOV*e[a+1]/(r+e[a+2])+o,d=FOV*e[l]/(r+e[l+2])+i,u=FOV*e[l+1]/(r+e[l+2])+o,g=FOV*e[h]/(r+e[h+2])+i,m=FOV*e[h+1]/(r+e[h+2])+o;c.strokeStyle=n,c.beginPath(),c.moveTo(f,p),c.lineTo(d,u),c.lineTo(g,m),c.lineTo(f,p),c.stroke(),c.fill()}c.fillStyle="#f008";for(let t=0;t<e.length;t+=3){let n=FOV*e[t]/(r+e[t+2])+i,s=FOV*e[t+1]/(r+e[t+2])+o;c.fillRect(n-4,s-4,8,8)}},renderMenu=(t,e,i,o,r,n)=>{const s=-(lastX-e/2)/20,a=-(lastY-i/2)/20;backgroundGradientV||(backgroundGradientV=t.createLinearGradient(0,0,0,i),backgroundGradientV.addColorStop(0,"#db7500"),backgroundGradientV.addColorStop(1,"#fbe5e0"),backgroundGradientH=t.createLinearGradient(0,0,e,0),backgroundGradientH.addColorStop(0,"#111"),backgroundGradientH.addColorStop(1,"#002")),t.save(),t.fillStyle=backgroundGradientV,t.fillRect(0,0,e,i),t.globalCompositeOperation="lighter",t.fillStyle=backgroundGradientH,t.fillRect(0,0,e,i),t.restore(),t.save(),t.globalAlpha=menuAlpha,t.lineWidth=2;let l=i/8,h=e/50;for(let r=0;r<o.length;r++)0!=r?(t.strokeStyle="#000",t.strokeRect(e/10+i/128,l+i/128,e/6,i/10),t.strokeStyle="#fff",t.strokeRect(e/10,l,e/6,i/10),lastX>=e/10&&lastX<=e/10+e/6&&lastY>=l&&lastY<=l+i/10&&(t.fillStyle="#fff",t.fillRect(e/10,l,e/6,i/10),clicked&&n(r))):(t.strokeStyle="#000",t.strokeRect(e/10+i/128+i/10,l+i/128,e/6,1),t.strokeStyle="#fff",t.strokeRect(0,l+i/10,e/4,1)),t.fillStyle="#000",drawText(t,o[r],e/10+e/12,l+i/20,h,1),l+=i/8;t.fillStyle="#f80",drawText(t,TITLE,e/2-10*h+2*s,i/2+.5*a,15*h,0,.2),t.fillStyle="#000",drawText(t,TITLE,e,h,h,2),t.fillStyle="#fff",drawText(t,TITLE,10*-h+.5*s,i-2*h+a,10*h,0,.4),t.restore(),rotateX(tmpArray,ship_vertex,-.2),rotateY(rotatedVertex,tmpArray,rot+movement);let c=2*e/3,f=1.75*i/3;t.globalAlpha=.5,t.lineWidth=4,drawWire(ship_indices,rotatedVertex,c+2*s,f+2*a,67.5,"#fff8"),drawWire(ship_indices,rotatedVertex,c+s,f+a,75)};